<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Dynamically Sized Types</title>
    <link rel="stylesheet" href="../style.css">
    <script defer src="../theme.js"></script>

    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                processEscapes: true
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
    <header>
        <h1>marcosfpr</h1>
        <nav>
            <a href="../index.html">Home</a> |
            <a href="index.html">Wiki</a> |
            <button id="theme-toggle" aria-label="Toggle light/dark">Light/Dark</button>
        </nav>
    </header>

    <main>
        
<div id="Dynamically Sized Types"><h1 id="Dynamically Sized Types" class="header"><a href="#Dynamically Sized Types">Dynamically Sized Types</a></h1></div>

<p>
Most Rust types have a fixed, known size at compile-time and automatically
implement the <code>Sized</code> trait.
</p>

<p>
A type whose size is known only at runtime is called a <span id="Dynamically Sized Types-dynamically sized type"></span><strong id="dynamically sized type">dynamically sized type</strong>
(DST), also known as an <span id="Dynamically Sized Types-unsized type"></span><strong id="unsized type">unsized type</strong> or a <code>?Sized</code> type.
</p>

<ul>
<li>
Slices such as <code>str</code>, <code>[T]</code>.

<li>
Trait objects such as <code>dyn Trait</code>.

</ul>
<div id="Dynamically Sized Types-Fat Pointers"><h2 id="Fat Pointers" class="header"><a href="#Dynamically Sized Types-Fat Pointers">Fat Pointers</a></h2></div>

<p>
A pointer to a DST, such as <code>&amp;str</code>, <code>Box&lt;dyn Trait&gt;</code>, or <code>&amp;[T]</code>, is called a
<span id="Dynamically Sized Types-Fat Pointers-fat pointer"></span><strong id="fat pointer">fat pointer</strong> because it contains extra metadata in addition to the raw
pointer:
</p>

<ul>
<li>
A slice pointer stores:

<ul>
<li>
a pointer to the first element, and

<li>
the length of the slice.

</ul>
<li>
A trait object pointer stores:

<ul>
<li>
a pointer to the underlying data, and

<li>
a pointer to the vtable (the method table for the trait).

</ul>
</ul>
<p>
Because a fat pointer can only carry <span id="Dynamically Sized Types-Fat Pointers-one vtable"></span><strong id="one vtable">one vtable</strong>, types like
<code>&amp;dyn (Foo + Bar)</code> are not allowed. The solution is to define a new trait that
combines both traits:
</p>

<pre rust>
trait FooBar: Foo + Bar {}
</pre>

<p>
and then use <code>&amp;dyn FooBar</code>.
</p>

<div id="Dynamically Sized Types-Dyn Compatibility"><h2 id="Dyn Compatibility" class="header"><a href="#Dynamically Sized Types-Dyn Compatibility">Dyn Compatibility</a></h2></div>

<p>
A trait is said to be <span id="Dynamically Sized Types-Dyn Compatibility-dyn-compatible"></span><strong id="dyn-compatible">dyn-compatible</strong> if it can be used to form a trait
object. There are
<a href="https://doc.rust-lang.org/1.90.0/reference/items/traits.html#dyn-compatibility">several rules</a>
for dyn-compatibility, but one common way to <span id="Dynamically Sized Types-Dyn Compatibility-opt out"></span><strong id="opt out">opt out</strong> is to require
<code>Self: Sized</code> in the trait definition:
</p>

<pre rust>
trait Foo where Self: Sized {
    fn foo(&amp;self);
}
</pre>

<p>
By adding <code>where Self: Sized</code>, we restrict the trait so it can only be
implemented for types with a known size at compile-time. This makes the trait
*<span id="Dynamically Sized Types-Dyn Compatibility-incompatible with trait objects"></span><strong id="incompatible with trait objects">incompatible with trait objects</strong>*, since trait objects are DSTs.
</p>

    </main>

    <footer>
        &copy; 2024 marcosfpr
    </footer>
</body>

</html>
