<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Newtypes</title>
    <link rel="stylesheet" href="../style.css">
    <script defer src="../theme.js"></script>

    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                processEscapes: true
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
    <header>
        <h1>marcosfpr</h1>
        <nav>
            <a href="../index.html">Home</a> |
            <a href="index.html">Wiki</a> |
            <button id="theme-toggle" aria-label="Toggle light/dark">Light/Dark</button>
        </nav>
    </header>

    <main>
        
<div id="Newtypes"><h1 id="Newtypes" class="header"><a href="#Newtypes">Newtypes</a></h1></div>

<p>
The <span id="Newtypes-newtypes"></span><strong id="newtypes">newtypes</strong> idiom is an important pattern in the Rust programming language.
A <span id="Newtypes-newtype"></span><strong id="newtype">newtype</strong> is basically a wrapper struct that encapsulates another type with additional
properties or constraints. This allows you to create distinct types that
cannot be confused with each other, even if they have the same underlying representation.
</p>

<p>
The biggest benefits of using newtypes is that they help you create a more expressive
type system for your domain model, it also guides you through the correct usage of your types,
error handling, and enforces invariants at compile time.
</p>

<p>
Some people will also say newtypes are great because they're a zero-cost abstraction, but that's
not really the point for this post.
</p>

<div id="Newtypes-A tiny example"><h2 id="A tiny example" class="header"><a href="#Newtypes-A tiny example">A tiny example</a></h2></div>

<p>
For example, taking from the <a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">Rust By Example</a> book, you can define a newtype for checking
different time units:
</p>

<pre rust>
struct Years(u64);

impl Years {
    fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}

struct Days(u64);

impl Days {
    fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn is_adult(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(25);
    let age_days = age.to_days();
    println!("Is an adult? {}", is_adult(&amp;age));
    println!("Is an adult? {}", is_adult(&amp;age_days.to_years()));
    // println!("Is an adult? {}", is_adult(&amp;age_days));
}
</pre>


<p>
As you can see, if we just use <code>u64</code> for both <code>Years</code> and <code>Days</code>, it's easy to mix them up.
Using newtypes prevents that mistake and creates a solid domain model where the
type system helps enforce correctness.
</p>

<p>
The newtypes work really well together with appropriate error types and validation logic
at construction time. That means we can ensure that the data inside the newtype is always valid.
Let's explore that in the next example.
</p>

<div id="Newtypes-A more interesting example"><h2 id="A more interesting example" class="header"><a href="#Newtypes-A more interesting example">A more interesting example</a></h2></div>

<p>
Now, let's look at a more interesting example that demonstrates how to use ewtypes to model
users in a simple application. Initially, we will have a <code>User</code> struct that contains an <code>Email</code> newtype
and a <code>UserType</code> enum to represent different user roles.
</p>

<pre rust>
use regex::Regex;
use thiserror::Error;

#[derive(Error, Debug)]
enum InvalidEmailError {
    #[error("email is malformed")]
    Malformed,
}

struct Email(String);

impl Email {
    fn new(email: &amp;str) -&gt; Result&lt;Self, InvalidEmailError&gt; {
        let email_regex = Regex::new(r"^[^@\s]+@[^@\s]+\.[^@\s]+$").unwrap();
        if email_regex.is_match(email) {
            Ok(Email(email.to_string()))
        } else {
            Err(InvalidEmailError::Malformed)
        }
    }
}

enum UserType {
    Regular,
    Admin,
}

struct User {
    email: Email,
    user_type: UserType,
}

impl User {
    fn new(email: Email, user_type: UserType) -&gt; Self {
        User { email, user_type }
    }
}
</pre>

<p>
Here, the <code>Email</code> newtype encapsulates a <code>String</code> and validates the email format
at construction time. The <code>User</code> struct uses the <code>Email</code> newtype to ensure
that only valid emails are associated with users.
</p>

<p>
Notice how the newtypes are powerful. It's impossible to create an incorrect
<code>User</code> because the <code>Email</code> newtype enforces the email format.
</p>

<p>
Now, let's create an <code>Admin</code> newtype that wraps a <code>User</code> and guarantees
that the user has admin privileges.
</p>

<pre rust>

#[derive(Error, Debug)]
enum InvalidAdmin{
    #[error("user is not an admin")]
    NotAdmin,
}

struct Admin(User);

impl Admin {
    fn new(user: User) -&gt; Result&lt;Self, InvalidAdmin&gt; {
        match user.user_type {
            UserType::Admin =&gt; Ok(Admin(user)),
            _ =&gt; Err(InvalidAdmin::NotAdmin),
        }
    }
}
</pre>

<p>
The <code>Admin</code> newtype ensures that only users with admin privileges can be
wrapped in it. This way, we can enforce role-based access control at the type level.
</p>

<p>
This example may seem simple, but it demonstrates the power of newtypes in creating
safer and more expressive domain models. By leveraging Rust's type system,
we can prevent many classes of bugs and ensure that our code adheres to the intended invariants.
</p>

<div id="Newtypes-Downsides"><h2 id="Downsides" class="header"><a href="#Newtypes-Downsides">Downsides</a></h2></div>

<p>
Some posts say the disavantages of newtypes are the boilerplate code and the need to implement
traits and methods for the newtypes. While that's true, the benefits and guarantees they provide
are far more valuable in most cases.
</p>

<div id="Newtypes-Conclusion"><h2 id="Conclusion" class="header"><a href="#Newtypes-Conclusion">Conclusion</a></h2></div>

<p>
I can tell you from experience that using newtypes has saved me from many bugs and design issues
in my professional projects.
</p>

<p>
Consider using them to model your application's domain more accurately.
</p>

    </main>

    <footer>
        &copy; 2024 marcosfpr
    </footer>
</body>

</html>
